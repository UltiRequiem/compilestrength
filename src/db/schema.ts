import { createId } from "@paralleldrive/cuid2";
import { relations } from "drizzle-orm";
import {
	boolean,
	index,
	integer,
	json,
	pgTable,
	real,
	text,
	timestamp,
} from "drizzle-orm/pg-core";

// Import Better Auth schema generated by CLI
export * from "./auth.schema";

import { users } from "./auth.schema";

// Workout Application Schema
export const workoutPrograms = pgTable(
	"WorkoutProgram",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		userId: text("userId")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		name: text("name").notNull(),
		description: text("description"),
		goalType: text("goalType").notNull(), // strength, hypertrophy, endurance, general
		experienceLevel: text("experienceLevel").notNull(), // beginner, intermediate, advanced
		frequency: integer("frequency").notNull(), // workouts per week
		durationWeeks: integer("durationWeeks").notNull(),
		isActive: boolean("isActive").notNull().default(true),
		createdAt: timestamp("createdAt").notNull().defaultNow(),
		updatedAt: timestamp("updatedAt").notNull().defaultNow(),
	},
	(table) => ({
		userIdIdx: index("WorkoutProgram_userId_idx").on(table.userId),
	}),
);

export const workoutDays = pgTable(
	"WorkoutDay",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		programId: text("programId")
			.notNull()
			.references(() => workoutPrograms.id, { onDelete: "cascade" }),
		dayNumber: integer("dayNumber").notNull(), // 1-7 for day of week
		name: text("name").notNull(), // "Push Day A", "Pull Day B"
		type: text("type").notNull(), // push, pull, legs, upper, lower, full, rest
		description: text("description"),
	},
	(table) => ({
		programIdIdx: index("WorkoutDay_programId_idx").on(table.programId),
	}),
);

export const exercises = pgTable("Exercise", {
	id: text("id")
		.primaryKey()
		.$defaultFn(() => createId()),
	name: text("name").notNull().unique(),
	description: text("description"),
	muscleGroup: text("muscleGroup").notNull(), // chest, back, legs, shoulders, arms, core
	equipmentType: text("equipmentType").notNull(), // barbell, dumbbell, machine, bodyweight, cable
	difficulty: text("difficulty").notNull(), // beginner, intermediate, advanced
	videoUrl: text("videoUrl"),
	createdAt: timestamp("createdAt").notNull().defaultNow(),
});

export const programExercises = pgTable(
	"ProgramExercise",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		workoutDayId: text("workoutDayId")
			.notNull()
			.references(() => workoutDays.id, { onDelete: "cascade" }),
		exerciseId: text("exerciseId")
			.notNull()
			.references(() => exercises.id),
		sets: integer("sets").notNull(),
		reps: text("reps").notNull(), // "8-12" or "10" for ranges
		restSeconds: integer("restSeconds").notNull().default(90),
		notes: text("notes"),
		order: integer("order").notNull(), // order in workout
	},
	(table) => ({
		workoutDayIdIdx: index("ProgramExercise_workoutDayId_idx").on(
			table.workoutDayId,
		),
		exerciseIdIdx: index("ProgramExercise_exerciseId_idx").on(table.exerciseId),
	}),
);

export const workoutSessions = pgTable(
	"WorkoutSession",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		userId: text("userId")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		workoutDayId: text("workoutDayId").references(() => workoutDays.id),
		startTime: timestamp("startTime").notNull().defaultNow(),
		endTime: timestamp("endTime"),
		notes: text("notes"),
		completedAt: timestamp("completedAt"),
	},
	(table) => ({
		userIdIdx: index("WorkoutSession_userId_idx").on(table.userId),
		workoutDayIdIdx: index("WorkoutSession_workoutDayId_idx").on(
			table.workoutDayId,
		),
	}),
);

export const workoutSets = pgTable(
	"WorkoutSet",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		sessionId: text("sessionId")
			.notNull()
			.references(() => workoutSessions.id, { onDelete: "cascade" }),
		exerciseId: text("exerciseId")
			.notNull()
			.references(() => exercises.id),
		setNumber: integer("setNumber").notNull(),
		reps: integer("reps").notNull(),
		weight: real("weight").notNull(),
		rpe: integer("rpe"), // Rate of Perceived Exertion 1-10
		completedAt: timestamp("completedAt").notNull().defaultNow(),
	},
	(table) => ({
		sessionIdIdx: index("WorkoutSet_sessionId_idx").on(table.sessionId),
		exerciseIdIdx: index("WorkoutSet_exerciseId_idx").on(table.exerciseId),
	}),
);

export const personalRecords = pgTable(
	"PersonalRecord",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		userId: text("userId")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		exerciseId: text("exerciseId")
			.notNull()
			.references(() => exercises.id),
		weight: real("weight").notNull(),
		reps: integer("reps").notNull(),
		recordType: text("recordType").notNull(), // 1rm, 3rm, 5rm, volume
		achievedAt: timestamp("achievedAt").notNull().defaultNow(),
	},
	(table) => ({
		userIdIdx: index("PersonalRecord_userId_idx").on(table.userId),
		exerciseIdIdx: index("PersonalRecord_exerciseId_idx").on(table.exerciseId),
	}),
);

export const userPreferences = pgTable("UserPreferences", {
	userId: text("userId")
		.primaryKey()
		.references(() => users.id, { onDelete: "cascade" }),
	units: text("units").notNull().default("lbs"), // lbs or kg
	restTimerDefault: integer("restTimerDefault").notNull().default(90), // seconds
	trainingGoal: text("trainingGoal"), // strength, hypertrophy, endurance
	experienceLevel: text("experienceLevel"), // beginner, intermediate, advanced
	availableDays: integer("availableDays"), // days per week
});

// Compiler Feature Tables
export const workoutRoutines = pgTable(
	"WorkoutRoutine",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		userId: text("userId")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		name: text("name").notNull(),
		description: text("description"),
		routine: json("routine").notNull(), // JSON object containing the full routine structure
		agentType: text("agentType").notNull().default("bodybuilding"), // bodybuilding, powerlifting, endurance, general
		conversationId: text("conversationId"),
		createdAt: timestamp("createdAt").notNull().defaultNow(),
		updatedAt: timestamp("updatedAt").notNull().defaultNow(),
	},
	(table) => ({
		userIdIdx: index("WorkoutRoutine_userId_idx").on(table.userId),
		conversationIdIdx: index("WorkoutRoutine_conversationId_idx").on(
			table.conversationId,
		),
	}),
);

export const agentConversations = pgTable(
	"AgentConversation",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		userId: text("userId")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		agentType: text("agentType").notNull(), // bodybuilding, powerlifting, endurance, general
		messages: json("messages").notNull(), // Array of UIMessage objects
		userProfile: json("userProfile"), // User profile data collected during conversation
		status: text("status").notNull().default("active"), // active, completed, archived
		createdAt: timestamp("createdAt").notNull().defaultNow(),
		updatedAt: timestamp("updatedAt").notNull().defaultNow(),
	},
	(table) => ({
		userIdIdx: index("AgentConversation_userId_idx").on(table.userId),
		statusIdx: index("AgentConversation_status_idx").on(table.status),
	}),
);

// LemonSqueezy Billing Tables
export const plans = pgTable("Plan", {
	id: text("id")
		.primaryKey()
		.$defaultFn(() => createId()),
	productId: integer("productId").notNull(),
	productName: text("productName"),
	variantId: integer("variantId").notNull().unique(),
	name: text("name").notNull(),
	description: text("description"),
	price: text("price").notNull(),
	isUsageBased: boolean("isUsageBased").default(false),
	interval: text("interval"),
	intervalCount: integer("intervalCount"),
	trialInterval: text("trialInterval"),
	trialIntervalCount: integer("trialIntervalCount"),
	sort: integer("sort"),
	createdAt: timestamp("createdAt").notNull().defaultNow(),
	updatedAt: timestamp("updatedAt").notNull().defaultNow(),
});

export const subscriptions = pgTable(
	"Subscription",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		lemonSqueezyId: text("lemonSqueezyId").unique().notNull(),
		orderId: integer("orderId").notNull(),
		name: text("name").notNull(),
		email: text("email").notNull(),
		status: text("status").notNull(),
		statusFormatted: text("statusFormatted").notNull(),
		renewsAt: text("renewsAt"),
		endsAt: text("endsAt"),
		trialEndsAt: text("trialEndsAt"),
		price: text("price").notNull(),
		isUsageBased: boolean("isUsageBased").default(false),
		isPaused: boolean("isPaused").default(false),
		subscriptionItemId: integer("subscriptionItemId"),
		userId: text("userId")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		planId: text("planId")
			.notNull()
			.references(() => plans.id),
		createdAt: timestamp("createdAt").notNull().defaultNow(),
		updatedAt: timestamp("updatedAt").notNull().defaultNow(),
	},
	(table) => ({
		userIdIdx: index("Subscription_userId_idx").on(table.userId),
		planIdIdx: index("Subscription_planId_idx").on(table.planId),
		lemonSqueezyIdIdx: index("Subscription_lemonSqueezyId_idx").on(
			table.lemonSqueezyId,
		),
	}),
);

export const webhookEvents = pgTable(
	"WebhookEvent",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		createdAt: timestamp("createdAt").notNull().defaultNow(),
		eventName: text("eventName").notNull(),
		processed: boolean("processed").default(false),
		body: json("body").notNull(),
		processingError: text("processingError"),
	},
	(table) => ({
		eventNameIdx: index("WebhookEvent_eventName_idx").on(table.eventName),
		processedIdx: index("WebhookEvent_processed_idx").on(table.processed),
	}),
);

export const usageTracking = pgTable(
	"UsageTracking",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => createId()),
		userId: text("userId")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		subscriptionId: text("subscriptionId")
			.notNull()
			.references(() => subscriptions.id, { onDelete: "cascade" }),
		periodStart: timestamp("periodStart").notNull(),
		periodEnd: timestamp("periodEnd").notNull(),
		compilesUsed: integer("compilesUsed").notNull().default(0),
		compilesLimit: integer("compilesLimit").notNull().default(1),
		routineEditsUsed: integer("routineEditsUsed").notNull().default(0),
		routineEditsLimit: integer("routineEditsLimit").notNull().default(5),
		aiMessagesUsed: integer("aiMessagesUsed").notNull().default(0),
		aiMessagesLimit: integer("aiMessagesLimit").notNull().default(50),
		createdAt: timestamp("createdAt").notNull().defaultNow(),
		updatedAt: timestamp("updatedAt").notNull().defaultNow(),
	},
	(table) => ({
		userIdIdx: index("UsageTracking_userId_idx").on(table.userId),
		subscriptionIdIdx: index("UsageTracking_subscriptionId_idx").on(
			table.subscriptionId,
		),
		periodIdx: index("UsageTracking_period_idx").on(
			table.periodStart,
			table.periodEnd,
		),
	}),
);

// Relations
export const workoutProgramsRelations = relations(
	workoutPrograms,
	({ one, many }) => ({
		user: one(users, {
			fields: [workoutPrograms.userId],
			references: [users.id],
		}),
		workoutDays: many(workoutDays),
	}),
);

export const workoutDaysRelations = relations(workoutDays, ({ one, many }) => ({
	program: one(workoutPrograms, {
		fields: [workoutDays.programId],
		references: [workoutPrograms.id],
	}),
	exercises: many(programExercises),
	workoutSessions: many(workoutSessions),
}));

export const exercisesRelations = relations(exercises, ({ many }) => ({
	programExercises: many(programExercises),
	workoutSets: many(workoutSets),
	personalRecords: many(personalRecords),
}));

export const programExercisesRelations = relations(
	programExercises,
	({ one }) => ({
		workoutDay: one(workoutDays, {
			fields: [programExercises.workoutDayId],
			references: [workoutDays.id],
		}),
		exercise: one(exercises, {
			fields: [programExercises.exerciseId],
			references: [exercises.id],
		}),
	}),
);

export const workoutSessionsRelations = relations(
	workoutSessions,
	({ one, many }) => ({
		user: one(users, {
			fields: [workoutSessions.userId],
			references: [users.id],
		}),
		workoutDay: one(workoutDays, {
			fields: [workoutSessions.workoutDayId],
			references: [workoutDays.id],
		}),
		sets: many(workoutSets),
	}),
);

export const workoutSetsRelations = relations(workoutSets, ({ one }) => ({
	session: one(workoutSessions, {
		fields: [workoutSets.sessionId],
		references: [workoutSessions.id],
	}),
	exercise: one(exercises, {
		fields: [workoutSets.exerciseId],
		references: [exercises.id],
	}),
}));

export const personalRecordsRelations = relations(
	personalRecords,
	({ one }) => ({
		user: one(users, {
			fields: [personalRecords.userId],
			references: [users.id],
		}),
		exercise: one(exercises, {
			fields: [personalRecords.exerciseId],
			references: [exercises.id],
		}),
	}),
);

export const userPreferencesRelations = relations(
	userPreferences,
	({ one }) => ({
		user: one(users, {
			fields: [userPreferences.userId],
			references: [users.id],
		}),
	}),
);

// Compiler Feature Relations
export const workoutRoutinesRelations = relations(
	workoutRoutines,
	({ one }) => ({
		user: one(users, {
			fields: [workoutRoutines.userId],
			references: [users.id],
		}),
		conversation: one(agentConversations, {
			fields: [workoutRoutines.conversationId],
			references: [agentConversations.id],
		}),
	}),
);

export const agentConversationsRelations = relations(
	agentConversations,
	({ one, many }) => ({
		user: one(users, {
			fields: [agentConversations.userId],
			references: [users.id],
		}),
		routines: many(workoutRoutines),
	}),
);

// LemonSqueezy Relations
export const plansRelations = relations(plans, ({ many }) => ({
	subscriptions: many(subscriptions),
}));

export const subscriptionsRelations = relations(
	subscriptions,
	({ one, many }) => ({
		user: one(users, {
			fields: [subscriptions.userId],
			references: [users.id],
		}),
		plan: one(plans, {
			fields: [subscriptions.planId],
			references: [plans.id],
		}),
		usageTracking: many(usageTracking),
	}),
);

export const usageTrackingRelations = relations(usageTracking, ({ one }) => ({
	user: one(users, {
		fields: [usageTracking.userId],
		references: [users.id],
	}),
	subscription: one(subscriptions, {
		fields: [usageTracking.subscriptionId],
		references: [subscriptions.id],
	}),
}));
